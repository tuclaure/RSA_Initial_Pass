from os import path
from os import makedirs
import base64
import sys
def get_user_input(prompt):
  """Gets a user input for a file path, checks that file exists before allowing return"""
  while(True):
    user_input = input(prompt) #get input from user
    if path.isfile(user_input): #check its a valid file
      return user_input
    else :
      print("Invalid Input")

def read_plain_text(path):
  """Reads in plain text to a string from a pre checked path"""
  try:
    with open(path, 'rb') as file: #read in the file as binary
      plain_text = file.read()
  except Exception as e:
    print(f"{e}")
    new_path = get_user_input("Text Path: ")
    plain_text = read_plain_text(new_path)
  return plain_text
  
def read_public_key(path):
  """Reads in a public key into a tupple
  Checks for the prescence of a Header and Footer
  Otherwise gets a new file and recursively uses itself
  """
  try:
    read_numbers = [] #list to start chunked key
    with open(path, 'r') as pem_file: #reading standard text (not the problem with program, numbers derived from this method are the same as generated by keyGenerate)
      for line in pem_file: #iterate through
        line = line.strip() #strip 
        if line and line != "-----BEGIN PUBLIC KEY-----" and line != "-----END PUBLIC KEY-----": #look for header and footer
          read_numbers.append(base64.b64decode(line)) #decode the base 64 string
    # Decode bytes back to integers
    decoded_n = int.from_bytes(read_numbers[0], byteorder='big')
    decoded_e = int.from_bytes(read_numbers[1], byteorder='big')
  except Exception as e:
    print(f"{e}")
    new_path = get_user_input("Public Key Path: ")
    decoded_n, decoded_e = read_public_key(new_path)
  return (decoded_n, decoded_e)

def write_cipher_text(cipher):
  """Writes out the encrypted text to CWD as cipher.enc"""
  #create folder if it doesnt exist
  if not path.exists('Output') :
    makedirs('Output')
    
  with open('Output/cipher.enc', 'wb') as file: #writes to cipher.enc always in binary
    file.write(cipher)
  
def encrypt(message, public_key):
  """ Encrypts a message using a public_key
  Arguments:
    message: String
    public_key: tupple holding n and e
  
  Returns:
    cipher_text: byte string containing the ciphered message"""

  #Encodes a message to base64 to handle strange bytes
  # turns messages into key size manipulable chunks
  # Encrypts message chunks using C = M^e mod n
  # returns all C chunks as a byte string
  
  n, e = public_key #get key numbers
  chunk_size = n.bit_length() // 8  # Calculate the maximum chunk size based on the modulus size
  cipher_text = b"" #byte string
  message_base64 = base64.b64encode(message) #encode the message as base64 to handle null bytes
  
  for i in range(0, len(message_base64), chunk_size): #loop through the message in chunks
    plain_chunk = message_base64[i:i + chunk_size] #get chunk of message
    plain_int = int.from_bytes(plain_chunk, 'big') #convert chunk to an integer
    cipher_int = pow(plain_int, e, n) #perform m^e mod n on chunk
    cipher_chunk = cipher_int.to_bytes(chunk_size, 'big') #convert chunk to bytes
    cipher_text += cipher_chunk #append bytes chunk to final byte string
  return cipher_text

def run_encrypt():
  """Executes the encryption program using internal functions"""
  
  if len(sys.argv) > 1: #for command line input
    text_path = sys.argv[1] #from command line
    key_path = 'Output/public_key.pem' if len(sys.argv) < 3 else sys.argv[2] #has default
  else:
    text_path = get_user_input("Text Path: ") #user input text location
    key_path = get_user_input("Public Key Path: ") #user input key location
      
  plain_text = read_plain_text(text_path) #get text as binary
  key = read_public_key(key_path) #get key as tupple of (n,e)
  cipher = encrypt(plain_text, key) #encrypt message, return the ciphered byte string
  write_cipher_text(cipher) #write the byte string

if __name__ == "__main__":
  run_encrypt()